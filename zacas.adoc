[[chapter2]]
== Word/Doubleword/Quadword CAS (AMOCAS.W/D/Q)

`AMOCAS.W` atomically loads 32-bits of a data value from address in `rs1`,
compares the loaded value to a 32-bit value held in `rd` and if the
comparison is bitwise equal, then stores the 32-bit value held in `rs2` to
the original address in `rs1`. The value loaded from memory is placed into
register `rd`. For RV64, `AMOCAS.W` always sign-extends the value placed in
`rd`, and ignores the upper 32 bits of the original value in `rd` and `rs2`.

[wavedrom, , ] 
.... 
{reg: [
  {bits:  7, name: 'opcode', attr:'AMO'},
  {bits:  5, name: 'rd', attr:'dest'},
  {bits:  3, name: '010', attr:'width'},
  {bits:  5, name: 'rs1', attr:'addr'},
  {bits:  5, name: 'rs2', attr:'src'},
  {bits:  1, name: 'rl'},
  {bits:  1, name: 'aq'},
  {bits:  5, name: '00101', attr:'AMOCAS.W'},
], config:{lanes: 1, hspace:1024}}
....

The operation performed by `AMOCAS.W` is as follows:

[source, ruby]
----
    temp = *[rs1]
    if temp == [rd]
        *[rs1] = [rs2]
    endif
    [rd] = temp
----

`AMOCAS.D` is similar to `AMOCAS.W` but operates on 64-bit data values.

[wavedrom, , ] 
.... 
{reg: [
  {bits:  7, name: 'opcode', attr:'AMO'},
  {bits:  5, name: 'rd', attr:'dest'},
  {bits:  3, name: '011', attr:'width'},
  {bits:  5, name: 'rs1', attr:'addr'},
  {bits:  5, name: 'rs2', attr:'src'},
  {bits:  1, name: 'rl'},
  {bits:  1, name: 'aq'},
  {bits:  5, name: '00101', attr:'AMOCAS.D'},
], config:{lanes: 1, hspace:1024}}
....

For RV32, `AMOCAS.D` atomically loads 64-bits of a data value from address in
`rs1`, compares the loaded value to a 64-bits value held in a register pair
consisting of `rd` and `rd+1` and if the comparison is bitwise equal, then
stores the 64-bit value held in the register pair `rs2` and `rs2+1` to the
original address in `rs1`. The value loaded from memory is placed into the
register pair `rd` and `rd+1`. The instruction requires the first register in
the pair to be even numbered; encodings with odd numbered registers specified
in `rs2` and `rd` are reserved. When the first register of a source register
pair is `x0`, then both halves of the pair read as zero. When the first
register of a destination register pair is `x0`, then the entire register
result is discarded and neither destination register is written.

The operation performed by `AMOCAS.D` for RV32 is as follows:

[source, ruby]
----
    temp0 = *([rs1]+0)
    temp1 = *([rs1]+4)

    comp0 = (rd == 0)  ? 0 : [rd];
    comp1 = (rd == 0)  ? 0 : [rd+1];

    swap0 = (rs2 == 0) ? 0 : [rs2];
    swap1 = (rs2 == 0) ? 0 : [rs2+1];

    If (temp0 == comp0) && (temp1 == comp1)
        *([rs1]+0) = swap0
        *([rs1]+4) = swap1
    endif

    if ( rd != x0 )
        [rd]   = temp0
        [rd+1] = temp1
    endif
----

For RV64, `AMOCAS.D` atomically loads 64-bits of a data value from address in
`rs1`, compares the loaded value to a 64-bit value held in `rd` and if the
comparison is bitwise equal, then stores the 64-bit value held in `rs2` to the
original address in `rs1`. The value loaded from memory is placed into register
`rd`.

The operation performed by `AMOCAS.D` for RV64 is as follows:

[source, ruby]
----
    temp = *[rs1]
    if temp == [rd]
        *[rs1] = [rs2]
    endif
    [rd] = temp
----

`AMOCAS.Q` (RV64 only) atomically loads 128-bits of a data value from address in
`rs1`, compares the loaded value to a 128-bits value held in a register pair
consisting of `rd` and `rd+1` and if the comparison is bitwise equal, then
stores the 128-bit value held in the register pair `rs2` and `rs2+1` to the
original address in `rs1`. The value loaded from memory is placed into the
register pair `rd` and `rd+1`. The instruction requires the first register in
the pair to be even numbered; encodings with odd numbered registers specified in
`rs2` and `rd` are reserved. When the first register of a source register pair
is `x0`, then both halves of the pair read as zero. When the first register of a
destination register pair is `x0`, then the entire register result is discarded
and neither destination register is written.

[wavedrom, , ] 
.... 
{reg: [
  {bits:  7, name: 'opcode', attr:'AMO'},
  {bits:  5, name: 'rd', attr:'dest'},
  {bits:  3, name: '100', attr:'width'},
  {bits:  5, name: 'rs1', attr:'addr'},
  {bits:  5, name: 'rs2', attr:'src'},
  {bits:  1, name: 'rl'},
  {bits:  1, name: 'aq'},
  {bits:  5, name: '00101', attr:'AMOCAS.Q'},
], config:{lanes: 1, hspace:1024}}
....

The operation performed by `AMOCAS.Q` is as follows:

.`AMOCAS.Q` operation
[source, ruby]
----
    temp0 = *([rs1]+0)
    temp1 = *([rs1]+8)

    comp0 = (rd == 0)  ? 0 : [rd];
    comp1 = (rd == 0)  ? 0 : [rd+1];

    swap0 = (rs2 == 0) ? 0 : [rs2];
    swap1 = (rs2 == 0) ? 0 : [rs2+1];

    If (temp0 == comp0) && (temp1 == comp1)
        *([rs1]+0) = swap0
        *([rs1]+8) = swap1
    endif

    if ( rd != x0 )
        [rd]   = temp0
        [rd+1] = temp1
    endif
----

[NOTE]
====
For a future RV128 extension, `AMOCAS.Q` would encode a single XLEN=128 register
in `rs2` and `rd`.
====

Just as for AMOs in the A extension, `AMOCAS.W/D/Q` requires that the address
held in `rs1` be naturally aligned to the size of the operand (i.e., 16-byte
aligned for 128-bit words, eight-byte aligned for 64-bit words, and four-byte
aligned for 32-bit words). If the address is not naturally aligned, an
address-misaligned exception or an access-fault exception will be generated.
The access-fault exception can be generated for a memory access that would
otherwise be able to complete except for the misalignment, if the misaligned
access should not be emulated. If the misaligned access could be emulated then
an address-misaligned exception may be generated.

The draft “Zam” extension, described in Chapter 23, relaxes this requirement
and specifies the semantics of misaligned AMOs.

Just as for AMOs in the A extension, the `amocas.w/d/q` optionally provides
release consistency semantics to help implement multiprocessor synchronization.
If the `aq` bit is set, then no later memory operations in this RISC-V hart can
be observed to take place before the `amocas.w/d/q` Conversely, if the `rl` bit
is set, then other RISC-V harts will not observe the instruction before memory
accesses preceding the instruction in this RISC-V hart. Setting both the `aq`
and the `rl` bit on an AMO makes the sequence sequentially consistent, meaning
that it cannot be reordered with earlier or later memory operations from the
same hart.

== AMO PMA

There are four levels of support defined within AMOs in the  A extension. Zacas
defines three additional levels of support: `AMOCasW`, `AMOCasD`, and `AMOCasQ`.

`AMOCasW` indicates that in addition to instructions indicated by `AMOArithmetic`
level support, the `amocas.w` instruction is supported. `AMOCasD` indicates that
in addition to instructions indicated by `AMOCasW` level support, the `amocas.d`
instruction is supported. `AMOCasQ` indicates that all RISC-V AMOs are supported.

[NOTE]
====
`AMOCasW/D/Q` requires `AMOArithmetic` level support as the `amocas.w/d/q`
instructions require ability to perform an arithmetic comparison and a swap
operation. 
====

